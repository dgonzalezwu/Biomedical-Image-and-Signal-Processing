# -*- coding: utf-8 -*-
"""
Created on Tue Apr 30 15:17:43 2019

@author: Danielle Gonzalez-Wu 
"""

import numpy as np 
import matplotlib.pyplot as plt 

x0 = 0 
y0 = 0
#%%
#Part 1: Simulate a wave pattern as generated by M radial point sources
#Let the M be the distance between the pixels. Chosen M value is 100
#Generating five points that are that chosen M value distance away from eachother 
Mvalues5 = [100,200,300,400,500]
sumsignal = 0 
#creating for loop like done in class to analyze these points
for x1 in range(0,5,1):
    x = np.tile(np.linspace(0,600,600),(600,1))
    index = Mvalues5[x1]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(1)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated by 5 250 Radial Point Sources')
plt.tight_layout()
plt.show()
#%%
#Part 2: Altering Wavelength
#Wavelength equation can be given as 1/Lambda and also as wavelength = vT 
#Sinusoidal Wavelength Equation follows as Asin((2*pi/vT)(x+vt))+ phi 
#Simplifting these equations shows where wavelength should be multiplied in the equation 
#Wavelength of 1.5 
wavelength1 = 1
Mvalues15 = [15, 30, 45, 60 , 75]
sumsignal = 0 
#creating for loop like done in class to analyze these points
for x15 in range(0,5,1): 
    x = np.tile(np.linspace(0,100,100),(100,1))
    index = Mvalues15[x15]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o*wavelength1) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(2)
    plt.subplot(2,2,1)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern \n with wavelength of 1')
#Wavelength of 2
wavelength2 = 1.25
sumsignal = 0 
Mvalues2 = [15, 30, 45, 60 , 75]
#creating for loop like done in class to analyze these points
for x2 in range(0,5,1): 
    x = np.tile(np.linspace(0,100,100),(100,1))
    index = Mvalues2[x2]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o*wavelength2) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(2)
    plt.subplot(2,2,2)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern \n with wavelength of 1.25')
#Wavelength of 2.5
wavelength3 = 1.5
sumsignal = 0 
Mvalues25 = [15, 30, 45, 60 , 75]
#creating for loop like done in class to analyze these points
for x25 in range(0,5,1): 
    x = np.tile(np.linspace(0,100,100),(100,1))
    index = Mvalues25[x25]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o*wavelength3) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(2)
    plt.subplot(2,2,3)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern \n with wavelength of 1.5')
#Wavelength of 3
wavelength4 = 1.75
sumsignal = 0
Mvalues3 = [15, 30, 45, 60 , 75]
#creating for loop like done in class to analyze these points
for x3 in range(0,5,1): 
    x = np.tile(np.linspace(0,100,100),(100,1))
    index = Mvalues3[x3]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o*wavelength3) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(2)
    plt.subplot(2,2,4)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern \n with wavelength of 1.75')
plt.tight_layout()
plt.show()
#%% 
#Part 2: Altering Distance 
#Let the M be the distacne between the pixels. Chosen M value is 40. 
Mvalues80 = [40,80,120,160,200]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x80 in range(0,5,1):
    x = np.tile(np.linspace(0,250,250),(250,1))
    index = Mvalues80[x80]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(3)
    plt.subplot(2,2,1)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 5 40 Radial Point Sources')
#Let the M be the distance between the pixels. Chosen M value is 30.
Mvalues60 = [30,60,90,120,150]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x60 in range(0,5,1):
    x = np.tile(np.linspace(0,200,200),(200,1))
    index = Mvalues60[x60]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(3)
    plt.subplot(2,2,2)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 5 30 Radial Point Sources')
#Let the M be the distacne between the pixels. Chosen M value is 20.
Mvalues40 = [20,40,60,80,100]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x40 in range(0,5,1):
    x = np.tile(np.linspace(0,150,150),(150,1))
    index = Mvalues40[x40]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(3)
    plt.subplot(2,2,3)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 5 20 Radial Point Sources')
#Let the M be the distacne between the pixels. Chosen M value is 10.
    Mvalues20 = [10,20,30,40,50]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x20 in range(0,5,1):
    x = np.tile(np.linspace(0,75,75),(75,1))
    index = Mvalues20[x20]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(3)
    plt.subplot(2,2,4)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 5 10 Radial Point Sources') 
plt.tight_layout()
plt.show()
#%%
#Part 2: Altering Number of Points 
#2 Points
Mvalues2 = [25,30]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x2 in range(0,2,1):
    x = np.tile(np.linspace(0,60,60),(60,1))
    index = Mvalues2[x2]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(4)
    plt.subplot(2,2,1)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 2 250 Radial Point Sources')
#4 Point
Mvalues4 = [25,30,35,40]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x4 in range(0,4,1):
    x = np.tile(np.linspace(0,80,80),(80,1))
    index = Mvalues4[x4]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(4)
    plt.subplot(2,2,2)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 4 250 Radial Point Sources')
#6 Points
Mvalues6 = [25,30,35,40,45,50]
sumsignal = 0
#creating for loop like done in class to analyze these points
for x6 in range(0,6,1):
    x = np.tile(np.linspace(0,100,100),(100,1))
    index = Mvalues6[x6]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(4)
    plt.subplot(2,2,3)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 6 250 Radial Point Sources')
#8 Points 
Mvalues8 = [25,30,35,40,45,50,55,60]
sumsignal = 0 
#creating for loop like done in class to analyze these points
for x8 in range(0,8,1):
    x = np.tile(np.linspace(0,100,100),(100,1))
    index = Mvalues8[x8]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(4)
    plt.subplot(2,2,4)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Wave pattern as generated \n by 8 250 Radial Point Sources')
plt.tight_layout()
plt.show()
#%%
#Part 2: What will give the narrowest "broadside" beam? 
#Wavelength pattern: As wavelength values increases, the "broadside beam" narrows further. 
#Distance between points pattern: As distance between points decreases, the "broadside beam" narrows further. 
#Number of origin points pattern: As number of origin points increases, the "broadside beam" narrows further. 
#ANSWER: The narrowest "broadside" beam will be given by a high wavelength value, a large distance between points, and a large number of origin points.
#Wavelength of 50
wavelength1 = 5.2
Mvalues15 = [20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]
sumsignal = 0 
#creating for loop like done in class to analyze these points
for x15 in range(0,14,1): 
    x = np.tile(np.linspace(0,150,150),(150,1))
    index = Mvalues15[x15]
    y = (x.T) - index #Shifting points downwards from 0 so the radius can originate at given points in y axis
    o = np.sqrt((x-x0)**2+(y-y0)**2) #circle equation 
    signal = np.sin(o*wavelength1) #generating 
    sumsignal += signal #summating all signals generated from points together into one graph
    plt.figure(5)
    plt.imshow(sumsignal, 'gray')
    plt.plot(0,index,'bo')
    plt.title('Generated narrowest possible "broadside" beam')
plt.tight_layout()
plt.ylim(0,50)
plt.show()
#%%
#Part 3: Determine how to place the elements so as to generate a focus at the a desired location.
Mvalues3 = [20,26,32,38,44]
sumsignal3 = 0
for x3 in range(0,5,1):    
    x = np.tile(np.linspace(0,250,250),(250,1)) 
    index3 = Mvalues3[x3]
    y=(x.T)-index3   
    o =np.sqrt(x**2+y**2)
    signal3 = np.sin(o - (2*x3)) #shifts each indice down by desired array amount #phase delay
    sumsignal3 += signal3  
    plt.figure(6)
    plt.plot(0,index3,'bo') 

Mvalues31 = [120,126,132,138,144]
sumsignal31 = 0
for x31 in range(0,5,1):    
    x = np.tile(np.linspace(0,250,250),(250,1)) 
    index31 = Mvalues31[x31]
    y=(x.T)-index31   
    o = np.sqrt(x**2+y**2)
    signal31 = np.sin(o)
    sumsignal31 += signal31  
    plt.figure(6)
    plt.plot(0,index31,'bo') 

Mvalues32 = [220,226,232,238,244] 
sumsignal32 = 0
for x32 in range(0,5,1):    
    x = np.tile(np.linspace(0,250,250),(250,1)) 
    index32 = Mvalues32[x32]
    y=(x.T)-index32   
    o = np.sqrt(x**2+y**2)
    signal32 = np.sin(o + (2*x32)) #shifts each indice down by desired array amount #phase delay 
    sumsignal32 += signal32 
    plt.figure(6)
    plt.plot(0,index32,'bo') 
    
plt.figure(6)
plt.imshow(sumsignal3 + sumsignal31 + sumsignal32, 'gray')
plt.title('Generated Focus at a desired location')
plt.tight_layout()
plt.show()
#%%
#Part 4: Determine how to introduce phase delays to steer the beam in lateral directions.
phasedelayangle = float(input('Please enter an angle in radians. (for reference: 0 to 90 degrees in radians is about 0 to 1.5)'))
Mvalues4 = [120,126,132,138,144]
sumsignal4 = 0
for x4 in range(0,5,1):    
    x = np.tile(np.linspace(0,250,250),(250,1)) 
    index4 = Mvalues4[x4]
    y=(x.T)-index4  
    o = np.sqrt(x**2+y**2)
    signal4 = np.sin(o + (phasedelayangle*x4))
    sumsignal4 += signal4 
    plt.figure(7)
    plt.plot(0,index4,'bo')
plt.imshow(sumsignal4, 'gray')
plt.title('Phase Delay of Specified Angle')
plt.tight_layout
plt.show()